---
  output: github_document
---

  <!-- README.md is generated from README.Rmd. Please edit that file -->

  ```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```
# groupedstats: Grouped statistical analysis in a tidy way

[![packageversion](https://img.shields.io/badge/Package%20version-0.0.1.9000-orange.svg?style=flat-square)](commits/master)
[![Travis Build Status](https://travis-ci.org/IndrajeetPatil/groupedstats.svg?branch=master)](https://travis-ci.org/IndrajeetPatil/groupedstats) 
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/IndrajeetPatil/groupedstats?branch=master&svg=true)](https://ci.appveyor.com/project/IndrajeetPatil/groupedstats) 
[![Licence](https://img.shields.io/badge/licence-GPL--3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0.en.html)
[![Project Status: Active - The project has reached a stable, usable state and is being actively developed.](http://www.repostatus.org/badges/latest/active.svg)](http://www.repostatus.org/#active)
[![Last-changedate](https://img.shields.io/badge/last%20change-`r gsub('-', '--', Sys.Date())`-yellowgreen.svg)](/commits/master)
[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-red.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![minimal R version](https://img.shields.io/badge/R%3E%3D-3.3.0-6666ff.svg)](https://cran.r-project.org/)
<!-- [![Coverage Status](https://img.shields.io/codecov/c/github/IndrajeetPatil/groupedstats/master.svg)](https://codecov.io/github/IndrajeetPatil/groupedstats?branch=master)
[![Dependency Status](http://img.shields.io/gemnasium/IndrajeetPatil/groupedstats.svg)](https://gemnasium.com/IndrajeetPatil/groupedstats) -->

## Overview

`groupedstats` package provides a collection of functions to run statistical
operations on multiple variables across multiple grouping variables in a
dataframe. This is a common situation in the following example cases-

1.  If you have combined multiple studies in a single dataframe and want to run
    a common operation (e.g., linear regression) on **each study**. In this
    case, column corresponding to `study` will be the grouping variable.
2.  If you have multiple groups in your dataframe (e.g., clinical disorder
    groups and controls group) and you want to carry out a common operation for
    **each group** (e.g., planned t-test to check for differences in reaction
    time in condition 1 versus condition 2). In this case, `group` will be the
    grouping variable.
3.  If you have multiple conditions in a given study (e.g., six types of videos
    participants saw) and want to run a common operation between different
    measures of interest for **each condition** (e.g., correlation between
    subjective rating of emotional intensity and reaction time).

**This package is still in development. Use at your own risk!**

## Installation

You can get the development version from GitHub. If you are in hurry and want to reduce the time of installation, prefer-

```{r installation1, eval = FALSE}
# install.packages("devtools")                                # needed package to download from GitHub repo
devtools::install_github(repo = "IndrajeetPatil/groupedstats", # package path on GitHub
                         quick = TRUE)                        # skips docs, demos, and vignettes
```

If time is not a constraint-
```{r installation2, eval = FALSE}
devtools::install_github(repo = "IndrajeetPatil/groupedstats", # package path on GitHub
                         dependencies = TRUE,                 # installs packages which groupedstats depends on
                         upgrade_dependencies = TRUE          # updates any out of date dependencies
)
```

## Help

Documentation for any function can be accessed with the standard `help` command-
```{r help, eval = FALSE}
?grouped_summary
?grouped_lm
?grouped_robustlm
?grouped_proptest
?grouped_ttest
```

## Usage

* `grouped_summary`

Getting summary for multiple variables across multiple grouping variables. This
function is a wrapper around [`skimr::skim_to_wide()`](https://www.rdocumentation.org/packages/skimr/versions/1.0.1/topics/skim_to_wide).

It is supposed to be a handy summarizing tool if you have just one grouping
variable and multiple variables for which summary statistics are to be computed-

```{r grouped_summary1}
library(datasets)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_summary(data = datasets::iris,
                              grouping.vars = Species,
                              measures = Sepal.Length:Petal.Width,
                              measures.type = "numeric")
```

This function can be used to get summary of either numeric **or** factor
varibles, but **not** both. If you want summary of variables of factor type-

```{r grouped_summary2}
library(ggplot2)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_summary(data = ggplot2::diamonds,
                              grouping.vars = c(cut, clarity),
                              measures = color,
                              measures.type = "factor")
```

Note that there is a column corresponding to `top_counts` which is really useful
in case you, let's say, want to plot these counts. But this column is of
`character` type and in wide format. The solution is to set an additional
argument provided for this function:

```{r grouped_summary3}
library(ggplot2)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_summary(data = ggplot2::diamonds,
                              grouping.vars = cut,         # for simplicity, let's just use one grouping variable
                              measures = color,
                              measures.type = "factor",
                              topcount.long = TRUE)
```

As seen, this produces a long format table with two new columns `factor.level`
and its corresponding `count`.

The benefit of formatted summary output is that, it can be directly fed into
other routines (e.g., preparing a plot of `mean` and `sd` values in `ggplot2`).

```{r grouped_summary4, warning = FALSE, message = FALSE}
library(tidyverse)

groupedstats::grouped_summary(
  data = datasets::mtcars,
  grouping.vars = c(am, cyl),
  measures = c(disp, wt, mpg),
  measures.type = "numeric"
) %>%                                                         # further modification with the pipe operator
  dplyr::select(.data = ., -type, -missing, -complete) %>%    # feeding the output into another function
  ggplot2::ggplot(data = .,                                   # note that `.` is just a placeholder for data here
                  mapping = ggplot2::aes(x = as.factor(cyl), 
                                         y = mean, 
                                         color = variable)) +
  ggplot2::geom_jitter() +
  ggplot2::labs(x = "No. of cylinders", y = "mean")
```

* `grouped_lm`

This function can be used to run linear regression between different pairs of
variables across multiple levels of grouping variable(s). For example, we can use
the `gapminder` dataset to study two relationships of interest for **each country** across years:
1.  life expectency and GDP (per capita)
2.  population GDP (per capita)
Thus, in this case we have two regression models and one grouping variable with 142 levels (countries)

```{r grouped_lm1}
library(gapminder)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_lm(data = gapminder::gapminder,
                         dep.vars = c(lifeExp, pop),
                         indep.vars = c(gdpPercap, gdpPercap),
                         grouping.vars = country)
```

Notice the order in which the dependent and independent variables are entered.
If this order is incorrect, the result will also be incorrect. So it is always a
good idea to check the *formula* column to see if you have run the correct
regression models. 

We saw example with one grouping variable. This can be done with multiple
grouping variables as well. For example, with the `diamonds` dataset from
`ggplot2` library to see the relation between carat and price of a diamond for
each type of clarity and cut-

```{r grouped_lm2, warning = FALSE, message = FALSE}
library(ggplot2)
library(dplyr)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_lm(data = ggplot2::diamonds,
                         dep.vars = price,
                         indep.vars = carat,
                         grouping.vars = c(cut, clarity)) %>%
  dplyr::arrange(.data = ., cut)
```

* `grouped_robustlm`

There is also robust variant of linear regression (as implemented in `robust::lmRob`)-

```{r grouped_robustlm, warning = FALSE, message = FALSE}
library(gapminder)
library(dplyr)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_robustlm(data = gapminder::gapminder,
                         dep.vars = c(lifeExp, pop),
                         indep.vars = c(gdpPercap, gdpPercap),
                         grouping.vars = c(continent, country)) %>%
  dplyr::arrange(.data = ., continent, country)
```

* `grouped_glm`

The option to run generalized linear model across different levels of the grouping variable-

```{r grouped_glm}
groupedstats::grouped_glm(data = datasets::mtcars,
                          dep.vars = am,
                          indep.vars = wt,
                          grouping.vars = cyl,
                          family = "gaussian")
```

* `grouped_proptest`

This function helps carry out one-sample proportion tests with a unique variable for multiple grouping variables-

```{r grouped_proptest}
library(datasets)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_proptest(data = mtcars,
                               grouping.vars = cyl,
                               measure = am)
```

* `grouped_ttest`

This function can help you carry out t-tests, paired or independent, on multiple
variables across multiple groups. Deomostrating how to use this function is
going to first require getting the `iris` dataset into long format. Let's say we
want to investigate if `Sepal` part of the flower has greater measurement
(length or width) than `Petal` part of the flower for **each** *Iris* species.

```{r grouped_ttest1}
# loading the necessary libraries
library(tidyverse)

# converting the iris dataset to long format
iris_long <- datasets::iris %>%
  dplyr::mutate(.data = ., id = dplyr::row_number(x = Species)) %>%
  tidyr::gather(
    data = .,
    key = "condition",
    value = "value",
    Sepal.Length:Petal.Width,
    convert = TRUE,
    factor_key = TRUE
  ) %>%
  tidyr::separate(
    col = "condition",
    into = c("part", "measure"),
    sep = "\\.",
    convert = TRUE
  ) %>%
  tibble::as_data_frame(x = .)

# check the long format iris dataset
iris_long

# checking if the Sepal part has different dimentions (value) than Petal part
# for each Species and for each type of measurement (Length and Width)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_ttest(
  data = iris_long,
  dep.vars = value,                    # dependent variable
  indep.vars = part,                   # independent variable
  grouping.vars = c(Species, measure), # for each Species and for each measurement
  paired = TRUE                        # paired t-test
)
```

* `grouped_wilcox`

This function is just non-parametric variant of the `grouped_ttest`:

```{r grouped_wilcox}
# checking if the Sepal part has different dimentions (value) than Petal part
# for each Species and for each type of measurement (Length and Width)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_wilcox(
  data = iris_long,
  dep.vars = value,                    # dependent variable
  indep.vars = part,                   # independent variable
  grouping.vars = c(Species, measure), # for each Species and for each measurement
  paired = TRUE                        # paired Wilcoxon signed rank test with continuity correction
)
```

While we are at it, let's also check out examples for `t-test` and `Wilcox test`
in case of between-subjects designs.

We will use `diamonds` dataset from `ggplot2` and will see if the price and
depth of a diamond is different for two of our favorite colors (say `E` and `J`)
for each type of clarity.

```{r grouped_wilcox2}

# subset the dataframe with two colors of interest to us
diamonds_short <-
  dplyr::filter(.data = ggplot2::diamonds, color == "E" |
                  color == "J")

options(tibble.width = Inf, tibble.print_max = Inf)             # show me all rows and columns

# t-test
groupedstats::grouped_ttest(
  data = diamonds_short,
  dep.vars = c(carat, price, depth),             # note that there three dependent variables 
  indep.vars = color,                            # and just one independent variable 
  grouping.vars = clarity,                       # one grouping variable
  paired = FALSE,
  var.equal = FALSE
)

# wilcox test (aka Mann-Whitney U-test)
groupedstats::grouped_wilcox(
  data = diamonds_short,
  dep.vars = depth:price,                        # note that you can select variables in range
  indep.vars = color,                            # again, just one independent, multiple dependent variables case
  grouping.vars = clarity,                       # one grouping variable
  paired = FALSE
)
```

We can further focus just on two levels of clarity to further elucidate another
aspect of entering the arguments-

```{r grouped_wilcox3}
# subset the dataframe even further to just select two levels of clarity
diamonds_short2 <-
  dplyr::filter(.data = diamonds_short, clarity == "SI2" |
                  clarity == "SI1")

# wilcox test (aka Mann-Whitney U-test)
groupedstats::grouped_wilcox(
 data = diamonds_short2,
  dep.vars = c(carat, price),                    # two dependent variables
  indep.vars = c(color, clarity),                # two independent variables
  grouping.vars = cut,                           # one grouping variable
  paired = FALSE
)

```

In these examples, two things are worth noting that generalize to **all**
functions in this package and stem from how [`tidy evaluation`](https://adv-r.hadley.nz/evaluation.html) works: <br />
 **1.** If just one independent variable is provided for multiple dependent
variables, it will be used as a common variable.  <br />
 **2.** If you want to use a selection of variables, you shouldn't use `c()`.

