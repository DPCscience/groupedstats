---
  output: github_document
---

  <!-- README.md is generated from README.Rmd. Please edit that file -->

  ```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```
# groupedstats: Grouped statistical analysis in a tidy way

[![packageversion](https://img.shields.io/badge/Package%20version-0.0.1.9000-orange.svg?style=flat-square)](commits/master)
[![Travis Build Status](https://travis-ci.org/IndrajeetPatil/groupedstats.svg?branch=master)](https://travis-ci.org/IndrajeetPatil/groupedstats) 
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/IndrajeetPatil/groupedstats?branch=master&svg=true)](https://ci.appveyor.com/project/IndrajeetPatil/groupedstats) 
[![Licence](https://img.shields.io/badge/licence-GPL--3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0.en.html)
[![Project Status: Active - The project has reached a stable, usable state and is being actively developed.](http://www.repostatus.org/badges/latest/active.svg)](http://www.repostatus.org/#active)
[![Last-changedate](https://img.shields.io/badge/last%20change-`r gsub('-', '--', Sys.Date())`-yellowgreen.svg)](/commits/master)
[![lifecycle](https://img.shields.io/badge/lifecycle-experimental-red.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![minimal R version](https://img.shields.io/badge/R%3E%3D-3.3.0-6666ff.svg)](https://cran.r-project.org/)
<!-- [![Coverage Status](https://img.shields.io/codecov/c/github/IndrajeetPatil/groupedstats/master.svg)](https://codecov.io/github/IndrajeetPatil/groupedstats?branch=master)
[![Dependency Status](http://img.shields.io/gemnasium/IndrajeetPatil/groupedstats.svg)](https://gemnasium.com/IndrajeetPatil/groupedstats) -->

## Overview

`groupedstats` package provides a collection of functions to run statistical
operations on multiple variables across multiple grouping variables in a
dataframe. **This package is still in development. Use at your own risk!**

## Installation

You can get the development version from GitHub. If you are in hurry and want to reduce the time of installation, prefer-

```{r installation1, eval = FALSE}
# install.packages("devtools")                                # needed package to download from GitHub repo
devtools::install_github(repo = "IndrajeetPatil/groupedstats", # package path on GitHub
                         quick = TRUE)                        # skips docs, demos, and vignettes
```

If time is not a constraint-
```{r installation2, eval = FALSE}
devtools::install_github(repo = "IndrajeetPatil/groupedstats", # package path on GitHub
                         dependencies = TRUE,                 # installs packages which groupedstats depends on
                         upgrade_dependencies = TRUE          # updates any out of date dependencies
)
```

## Help

Documentation for any function can be accessed with the standard `help` command-
```{r help, eval = FALSE}
?grouped_summary
?grouped_lm
?grouped_robustlm
?grouped_proptest
?grouped_ttest
```

## Usage

* `grouped_summary`

Getting summary for multiple variables across multiple grouping variables. This
function is a wrapper around [`skimr::skim_to_wide()`](https://www.rdocumentation.org/packages/skimr/versions/1.0.1/topics/skim_to_wide).

It is supposed to be a handy summarizing tool if you have just one grouping
variable and multiple variables for which summary statistics are to be computed-

```{r grouped_summary1}
library(datasets)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_summary(data = datasets::iris,
                              grouping.vars = Species,
                              measures = Sepal.Length:Petal.Width,
                              measures.type = "numeric")
```

This function can be used to get summary of either numeric **or** factor
varibles, but **not** both. If you want summary of variables of factor type-

```{r grouped_summary2}
library(ggplot2)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_summary(data = ggplot2::diamonds,
                              grouping.vars = c(cut, clarity),
                              measures = color,
                              measures.type = "factor")
```

The benefit of formatted summary output is that, it can be directly fed into
other routines (e.g., preparing a plot of `mean` and `sd` values in `ggplot2`).

```{r grouped_summary3, warning = FALSE, message = FALSE}
library(datasets)
library(tidyverse)

groupedstats::grouped_summary(
  data = datasets::mtcars,
  grouping.vars = c(am, cyl),
  measures = c(disp, wt, mpg),
  measures.type = "numeric"
) %>%                                                         # further modification with the pipe operator
  dplyr::select(.data = ., -type, -missing, -complete) %>%    # feeding the output into another function
  ggplot2::ggplot(data = .,                                   # note that `.` is just a placeholder for data here
                  mapping = ggplot2::aes(x = as.factor(cyl), 
                                         y = mean, 
                                         color = variable)) +
  ggplot2::geom_jitter() +
  ggplot2::labs(x = "No. of cylinders", y = "mean")
```

As demonstrated, 

* `grouped_lm`

This function can be used to run linear regression between different pairs of variables across multiple levels of grouping variables. For example, if we want to assess the linear relationship between `Sepal.Length` and `Sepal.Width`, **and** `Sepal.Length` and `Sepal.Width` (notice the order in which variables are being entered) for all levels of `Species`:    

```{r grouped_lm1}
library(datasets)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_lm(data = datasets::iris,
                         dep.vars = c(Sepal.Length, Petal.Length),
                         indep.vars = c(Sepal.Width, Petal.Width),
                         grouping.vars = Species)
```

This can be done with multiple grouping variables. For example, in the following
example, we use the `gapminder` dataset to regress life expectency and
population on GDP per capita for each continent and for each country.

```{r grouped_lm2, warning = FALSE, message = FALSE}
library(gapminder)
library(dplyr)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_lm(data = gapminder::gapminder,
                         dep.vars = c(lifeExp, pop),
                         indep.vars = c(gdpPercap, gdpPercap),
                         grouping.vars = c(continent, country)) %>%
  dplyr::arrange(.data = ., continent, country)
```

* `grouped_robustlm`

There is also robust variant of linear regression (as implemented in `robust::lmRob`)-

```{r grouped_robustlm, warning = FALSE, message = FALSE}
library(gapminder)
library(dplyr)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_robustlm(data = gapminder::gapminder,
                         dep.vars = c(lifeExp, pop),
                         indep.vars = c(gdpPercap, gdpPercap),
                         grouping.vars = c(continent, country)) %>%
  dplyr::arrange(.data = ., continent, country)
```

* `grouped_proptest`

This function helps carry out one-sample proportion tests with a unique variable for multiple grouping variables-

```{r grouped_proptest}
library(datasets)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_proptest(data = mtcars,
                               grouping.vars = cyl,
                               measure = am)
```

* `grouped_ttest`

This function can help you carry out t-tests, paired or independent, on multiple
variables across multiple groups. Deomostrating how to use this function is
going to first require getting the `iris` dataset into long format. Let's say we
want to investigate if `Sepal` part of the flower has greater measurement
(length or width) than `Petal` part of the flower for **each** *Iris* species.

```{r grouped_ttest1}
# loading the necessary libraries
library(tidyverse)

# converting the iris dataset to long format
iris_long <- datasets::iris %>%
  dplyr::mutate(.data = ., id = dplyr::row_number(x = Species)) %>%
  tidyr::gather(
    data = .,
    key = "condition",
    value = "value",
    Sepal.Length:Petal.Width,
    convert = TRUE,
    factor_key = TRUE
  ) %>%
  tidyr::separate(
    col = "condition",
    into = c("part", "measure"),
    sep = "\\.",
    convert = TRUE
  ) %>%
  tibble::as_data_frame(x = .)

# check the long format iris dataset
iris_long

# checking if the Sepal part has different dimentions (value) than Petal part
# for each Species and for each type of measurement (Length and Width)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_ttest(
  data = iris_long,
  dep.vars = value,                    # dependent variable
  indep.vars = part,                   # independent variable
  grouping.vars = c(Species, measure), # for each Species and for each measurement
  paired = TRUE                        # paired t-test
)
```

* `grouped_wilcox`

This function is just non-parametric variant of the `grouped_ttest`:

```{r grouped_wilcox}
# checking if the Sepal part has different dimentions (value) than Petal part
# for each Species and for each type of measurement (Length and Width)
options(tibble.width = Inf)            # show me all columns

groupedstats::grouped_wilcox(
  data = iris_long,
  dep.vars = value,                    # dependent variable
  indep.vars = part,                   # independent variable
  grouping.vars = c(Species, measure), # for each Species and for each measurement
  paired = TRUE                        # paired Wilcoxon signed rank test with continuity correction
)
```

While we are at it, let's also check out examples for `t-test` and `Wilcox test`
in case of between-subjects designs.

We will use `diamonds` dataset from `ggplot2` and will see if the price and
depth of a diamond is different for two of our favorite colors (say `E` and `J`)
for each type of clarity.

```{r grouped_wilcox2}

# subset the dataframe with two colors of interest to us
diamonds_short <-
  dplyr::filter(.data = ggplot2::diamonds, color == "E" |
                  color == "J")

options(tibble.width = Inf, tibble.print_max = Inf)             # show me all rows and columns

# t-test
groupedstats::grouped_ttest(
  data = diamonds_short,
  dep.vars = c(carat, price, depth),             # note that there three independent variables 
  indep.vars = color,                            # and just one dependent variable 
  grouping.vars = clarity,                       # one grouping variable
  paired = FALSE,
  var.equal = FALSE
)

# wilcox test (aka Mann-Whitney U-test)
groupedstats::grouped_wilcox(
  data = diamonds_short,
  dep.vars = depth:price,                        # note that you can select variables in a range
  indep.vars = color,                            # again, just one dependent variable
  grouping.vars = clarity,                       # one grouping variable
  paired = FALSE
)
```

We can further focus just on two levels of clarity to further elucidate another
aspect of entering the arguments-

```{r grouped_wilcox3}
# subset the dataframe even further to just select two levels of clarity
diamonds_short2 <-
  dplyr::filter(.data = diamonds_short, clarity == "SI2" |
                  clarity == "SI1")

# wilcox test (aka Mann-Whitney U-test)
groupedstats::grouped_wilcox(
 data = diamonds_short2,
  dep.vars = c(carat, price),                    # two independent variables
  indep.vars = c(color, clarity),                # and just one dependent variable 
  grouping.vars = cut,                           # one grouping variable
  paired = FALSE
)

```

In these examples, two things are worth noting that generalize to **all**
functions in this package and stem from how [`tidy evaluation`](https://adv-r.hadley.nz/evaluation.html) works: <br />
 **1.** If just one independent variable is provided for multiple dependent
variables, it will be used as a common variable.  <br />
 **2.** If you want to use a selection of variables, you shouldn't use `c()`.

